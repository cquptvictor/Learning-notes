# 第一章

### 编译器和解释器之间的区别是什么

- 答：编译器将高级语言程序翻译成汇编或机器语言程序，完整翻译后执行、执行速度快。解释程序逐句处理源程序，交互性好、错误诊断效果好

### 编译器产生汇编语言而不是机器语言的好处是什么

- 答：因为汇编语言比较容易输出和调试

### 把一种高级语言翻译成伟另一种高级语言的编译器称为源到源的翻译器。编译器使用C语言作为目标语言有什么好处

- 答：

### 描述一下汇编器所要完成的任务

- 答：把汇编语言程序翻译成机器代码；

### 编译器的模块结构

- 答：编译器有8个功能模块，包括4个分析模块、2个综合模块和2个辅助模块。分析模块有词法分析、语法分析、语义分析、中间代码生成；综合模块有代码优化、目标代码生成；辅助模块有符号表管理、出错处理。分析和综合模块构成了编译的6个有序步骤，2个辅助模块贯穿始终。
- 编译程序的绝大部分时间花在了表格管理上

### 编译器各阶段的主要功能

- 词法分析：读入词素，输出词法单元<token,attribute>；过滤注释和空白符、定位词法错误、查填符号表；
- 语法分析：判断程序结构是否正确，与上下文无关；通常采用语法分析树表示；
- 语义分析：检查源程序是否和语言定义的语义一致，比如类型检查；
- 中间代码生成：易于生成，能够轻松地被翻译为目标机器上的语言；
- -----------------------------------前端-后端------------------------------------------
- 代码优化：
- 代码生成：中间指令被翻译成能够完成相同任务的机器指令序列

# 第二章

### 基础概念

- 语法：描述了语言的程序的正确形式；通过上下文无关文法来描述语法；
- 语义：定义了程序的含义；
- 语言：从开始符号推导得到的所有终结符号串的集合称为该文法定义的语言
- 零个终结符号组成的串称为空串
- 符号串：字母表中符号组成的任意有穷序列
- 字母：字母表中的元素
- 字母表：元素符号的非空有穷集合
- 幂运算：∑<sup>n</sup> = ∑<sup>n-1</sup>∑；∑<sup>0</sup> = 空串
- 克林闭包和正则闭包：克林闭包多一个空串

### 文法

- 一个终结符号集合
- 一个非终结符号集合
- 一个产生式集合
- 一个非终结符号的开始符号

### 语法分析树

- 根节点是文法的开始符号
- 每个叶子结点的标号为一个终结符号或者空串
- 每个内部结点的标号为一个非终结符号

#### 二义性

- 一个文法可能有多课语法分析树能够生成同一个给定的终结符号串
- 通过附加规则来解决：运算符的结合性、优先级

### 最左、最右推导

- 每一步推导都是对最左（最右）非终结符的替换

### 上下文无关文法

1. 满足文法的定义
2. 产生式集合中所有｜α｜≤｜β｜， 除 Ｓ→ε外
3. α∈Ｖ<sub>N</sub>，β∈(Ｖ<sub>N</sub>∪Ｖ<sub>T</sub>)

# 第三章——词法分析

### 作用

- 读入源程序中的输入字符，将它们组合成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。
- 过滤掉源程序中的注释和空白
- 将编译器生成的错误消息与源程序的位置联系起来

### 基础概念

- 词法单元：由一个词法单元名和一个可选的属性值组成
- 模式：描述了一个词法单元的词素可能具有的形式（描述了构成规则）
- 词素：源程序中一个字符序列
- 连接：xy代表把串y附加到串x后面形成的串
- 前缀、后缀、子串、真前缀、真后缀、真子串、子序列

### 正则表达式

- 正则表达式可以描述所有通过对某个字母表上的符号应用这些运算符得到的语言
- 每个正则表达式r代表一个语言L(r)
- 表示同样语言的两个正则表达式等价
- 区分正则表达式和正则定义

#### 归纳基础

- 空串是一个正则表达式，它构成的语言只包含空串
- 字母表上的一个符号是一个正则表达式，它构成的语言仅包含一个长度为1的符号串

#### 归纳步骤

- (r)|(s)是一个正则表达式，表式语言L(r)UL(s)
- (s)(r)是一个正则表达式，表示语言L(r)L(s)
- (r)\*是一个正则表达式，表示语言(L(r))\*
- (r)是一个正则表达式，表示语言L(r)
- *具有最高优先级，左结合
- 连接具有次高优先级，左结合
- |优先级最低，左结合

### 状态转换图

- "状态"（结点或圆圈）+边（从一个状态指向另一个状态）
- 双层圈表示接受状态
- 如果需要将forward回退一（N）个位置，那么我们要在接受状态上加一（N）个*。

### 有穷自动机

- 不确定有穷自动机：对其边上的标号没有任何限制，空串也可以作为标号
- 确定的有穷自动机：对于每个状态及自动机输入字母表中的每个符号，有且只有一个能够离开该状态、以该符号为标号的边。
- NFA和DFA能欧冠识别的语言的集合是相同的，正好能够用正则表达式描述。

#### 组成

- 一个有穷的状态集合S
- 一个输入符号集合
- 一个转换函数
- 一个开始状态s<sub>0</sub>
- 一个接受状态集F

### NFA到DFA

- 子集构造法
- 找NFA的开始符号的等价状态集T（即开始状态通过空串可到达的）
- 找move(T,a)，找它的等价
- 重复前面两步，直到不出现新的状态集

#### 自动机和状态转换图的区别

- 自动机的同一符号可以标记从同一状态触发到达多个目标状态的多条边
- 自动机的一条边的标号不仅可以是输入字母表中的符号，也可以是空串

# 第四章——语法分析

### 作用

- 从词法分析器中获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成

### 基本概念

- 自顶向下：从语法分析树的顶部开始向底部构造语法分析树；适用LL文法
- 自底向上：从叶子结点开始，逐渐向根节点方向构造；适用LR文法
- 句型：文法G的开始符号S通过零步或多步推导出的符号串a，被称为文法G的一个句型；句型可能既包含终结符号，又包含非终结符号，也可能是空串。
- 句子：不包含非终结符号的句型
- 生成相同语言的文法是等价的
- 每一个正则语言都是一个上下文无关语言，但反之不成立

### 回溯

- 

#### 消除

- 提取左公因子，引入语法变量

### 二义性

- 一个文法可以为某个句子生成多课语法分析树，那么他就是二义性的

#### 消除

- 引入语法变量，使文法含有更多信息
- 见p123

### 左递归

- 一个非终结符号A经过一次或多次推导得到Aa，那么这个文法就是左递归的
- 自顶向下文法需要消除左递归

#### 消除

-  立即左递归直接消除
- 间接左递归化为立即左递归，然后消除
- 详见p123 - 124

### 提取左公因子

- 是一种文法转换方法，产生适用于预测分析技术和自顶向下分析技术的文法

### FIRST和FOLLOW

- FIRST(a)被定义为可以从a推导得到的串的首符号集合
- FOLLOW（A）被定义为可能在某些句型中紧跟在A右边的终结符号的集合
- FOLLOW集合没有空串

### 根据FIRST和FOLLOW求预测表

### 非递归预测分析器模型结构

- 输入缓冲区(符号序列)、栈、预测分析控制程序、预测分析表、输出（产生式序列）

### 句柄和归约

- 一次归约是一个推导（最右推导）步骤的反向操作
- 句柄是和某个产生式体匹配的子串（匹配不一定就是句柄，前提是能从开始符号推导得到），对它的归约代表了相应的最右推导中的一个反向步骤
- 句柄右边的串一定只包含终结符号
- 无二义性的文法，每个句型只有一个句柄

# 第五章——语法制导的翻译

### 综合属性

- 在分析树结点N上的非终结符号A的综合属性是由N上的产生式所关联的语义规则来定义的
- 允许结点N的一个综合属性通过结点N本身的继承属性来定义

### 继承属性

- 在分析树结点N上的非终结符号B的继承属性是由N的父节点上的产生式所关联的语义规则来定义的
- 不允许结点N上的继承属性通过N的子节点上的属性值来定义
- 终结符号可以具有综合属性，但是不能有继承属性

### 注释语法分析树

- 注释语法分析树是显示了各个结点的各属性值的语法分析树

# 第六章——中间代码生成

### 三地址代码

- 一条指令的右侧最多有一个运算符
- 例6.5
- 注意单目运算符和双目运算符

### 三地址码中的三地址是指的哪三个地址

- 第一操作数地址、第二操作数地址、目的操作数地址
- 地址可能是名字、常量、编译器生成的临时变量

### 四元式表示

- op、arg<sub>1</sub>、arg<sub>2</sub>、result
- 例6.6 

### 函数（过程）调用

- 在处理一个过程/函数时，它声明的变量应该放到单独的符号表中去；可以为每个记录创建单独的符号表

### 布尔表达式代码的SSD

### 回填

- 回填技术解决某些跳转指令应该跳转到哪里的关键问题；生成跳转指令时暂时不指定目标标号，使用列表分别记录这些不完整的指令，等直到正确的目标时再填写目标标号，每个列表中的指令都指向同一个目标。



