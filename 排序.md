# 选择排序

- 每次从一个未排序的队列中选择一个最小的放入到已排序的队列的末尾

- $$
  一共需要进行n-1次交换，n^2/2次比较
  $$

- 运行时间和输入无关，已经有序的数组和完全无序的数组的排序时间相同

- 交换次数和数组大小是线性关系

- 适用于小数组

- $$
  时间复杂度n^2
  $$

  

# 插入排序

- 每次把无序队列中的值插入到有序队列中的合适位置

- 对一个已经有序或接近有序的数组进行排序会更快

- 适用于小数组

- 对于大规模乱序数组排序很慢，只能交换相邻的元素

- 稳定排序

- $$
  时间复杂度n^2
  $$

# 希尔排序

- 每次排序使间隔为h的元素变成有序的，不断减小h的值，h=1的时候，相当于是插入排序

- 希尔排序比插入排序和选择排序快得多，并且数组越大，优势越大

- 希尔排序是对插入排序的改进，部分有序的结果很适合插入排序

- $$
  时间复杂度与增量有关，平均时间复杂度nlog2n
  $$

# 归并排序

- 将数组分成两个子数组分别排序，然后对排好序的子数组进行归并

- 自顶向下（递归），自底向上（循环）

- 分治思想

- 稳定排序

- $$
  时间复杂度NlgN
  $$

  

# 快速排序

- 将数组分成两个子数组分别排序，左子数组全部小于基准值，右子数组全部大于基准值；子数组不断分为子数组，直到数组长度为1;子数组全部有序时，数组就整体有序了

- 平均情况下是最快的排序算法

- $$
  平均时间复杂度是NlgN，最坏是n^2
  $$

  

# 堆排序

- 堆通过反复的delMin()操作，每次都能删除一个最小值，从而得到一个有序序列

- 10000个数中，只选择10个最大（小）的数就适合用堆排序

- 堆排序比快速排序稳定，但是通常情况下快速排序是最快的

- $$
  时间复杂度 NlogN
  $$

## 堆

- 以完全二叉树的形式表示，用数组存储
- 符合完全二叉树的性质，序号为k的点的左右子节点分别为2k,2k+1
- 入队和出队的时间复杂度相同logN
- 主要有上浮和下滤操作

