# 第二章——Java内存区域与内存溢出异常

## 运行时数据区域

### 线程共享

#### Java堆

- 存放对象实例，数组
- 垃圾回收管理的主要区域
- 可以处于逻辑上连续，物理上不连续的内存空间

#### 方法区

- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

#### 运行时常量池

- 方法区的一部分
- 存放编译器生成的各种字面量和符号引用
- 动态性

### 非线程共享

#### 程序计数器

- 当前线程所执行的字节码的行号指示器
- 字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令
- Native方法计数器会为空

#### Java虚拟机栈

- 栈帧：用于存储局部变量表、操作数栈、动态链接等信息
- 方法调用时会创建一个栈帧，有相应的出栈入栈操作

#### 本地方法栈

- 类似于虚拟机栈，只不过执行的是本地方法

## 对象

### 对象的创建

1. 检查，类加载
2. 分配内存
3. 内存空间初始化为0

##### 指针碰撞

- 适用于Java堆内存是绝对工整的
- 分配内存时，仅需要把指针向空闲空间方向移动

##### 空闲列表

- 适用于Java堆内存是不工整的
- 通过维护一个列表来记录哪些内存块是可用的

### 对象的内存布局

#### 对象头

- Mark Word：第一部分用于存储对象自身的运行时数据
- 另一部分是类型指针，来确定对象那个是哪个类的实例

### 实例数据

- 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容
- 相同宽度的字段总是被分配在一起，在此前提下，父类定义的变量出现在子类之前

### 对象填充

- HotSpot VM要求对象起始地址必须是8字节的整数倍

### 对象的访问定位

#### 句柄访问

- Java堆中会划分出一块内存来作为句柄池
- reference存储对象的句柄地址
- 句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 好处：reference中鵆的稳定句柄地址，对象被移动时，不需要改变

#### 直接指针访问

- reference中存储的直接就是对象地址
- 速度快，节省了一次指针定位的时间开销
- Sun HotSpot采用这种方式

# 第三章——垃圾收集器与内存分配策略

## 对象是否存活

### 引用计数算法

#### 原理

- 每有一个地方引用对象时，引用计数器加1；每有一个引用失效时，引用计数器减1；当计数器为0时，对象被回收

#### 缺点

- 无法解决循环引用问题
- `ObjectA.attr = ObjectB, ObjectB.attr = ObjectA`

### 可达性分析算法

#### 原理

- 通过一系列的GC Root对象作为起始点，从这些结点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Root没有任何引用链，则该对象需要被回收

#### GC Root对象

- 虚拟机栈中引用的对象（即栈中本地变量表）
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中Native方法引用的对象

### 引用

- 强引用：通常意义上的引用
- 软引用：在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围之中进行二次回收
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前
- 虚引用：不对对象生存周期产生影响，唯一目的能在对象被GC回收时收到一个系统通知

### 对象回收

1. 先判断此对象是否要执行finalize()方法；方法没有被覆盖，或者已经执行过一次，则没有必要执行
2. 有必要执行的对象放入F-Queue队列之中去执行（只会触发方法，不会等待结束，避免GC崩溃）
3. 再次判断是否要回收该对象（如果在finalize方法中，对象有了一个新引用，就避免了被回收的命运）

### 回收方法区

- 主要是回收废弃常量和无用的类
- 回收效率低

#### 废弃常量

- 没有引用指向常量池中的常量

#### 无用的类

- 该类的所有实例都已经被回收
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象那个没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾收集算法

### 标记-清除算法

#### 原理

- 首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象

#### 特点

- 效率不高
- 空间零碎，分配大对象时不方便

### 复制算法

#### 原理

- 内存分为两块，将一块内存用完之后，就把存活的对象复制到另一块上，然后清除第一块

#### 特点

- 内存需要缩小一半

#### 实际应用

- 新生代按照Edent:Survivor:Survivor = 8:1:1划分
- 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

### 标记-整理算法

- 标记过程和标记-清除算法一样，但是并不直接对可回收对象清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集

- 将堆内存分为老年代和新生代，根据各个代不同的特点选择适当的收集算法

## HotSpot算法的实现

### 枚举根节点

- 一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上；保证对象的引用关系不会不断变化；因此需要`Stop The World`
- 为了方便的的值哪些地方存放着对象的引用，采用了OopMap的数据结构
- 在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用

### 安全点

- 在“特定位置记录了这些信息”，这些位置被称为安全点
- STW只有在到达安全点才能暂停
- 以“是否具有让程序尝试加难治性的特征”为标准选定

#### 抢先式中断

- 先把所有的线程中断，有的线程若不在安全点上，则恢复线程，运行到安全点再中断、
- 几乎不用

### 主动式中断

- 设置一个标志，线程执行时主动去轮询这个标志，发现标志为true时就自己中断

### 安全区域

- 指在一段代码片段中，引用关系不会发生变化
- 例如，线程处于Sleep或Blocked状态时

## 垃圾收集器

### CMS

- Concurrent Mark Sweep
- 一种以获取最短回收挺短时间为目标的收集器
- 适用于老年代
- 标记-清除算法

### 运作过程

1. 初始标记：标记GC Roots能直接关联到的对象，需要STW
2. 并发标记：进行GC Roots Tracing
3. 重新标记：修正标记并发期间的变动（处理新增关系不被GC，忽略删除关系），需要STW
4. 并发清除

### 缺点

- 对CPU资源敏感，占用CPU资源导致程序变慢
- 无法处理浮动垃圾
- 标记-清除算法产生空间碎片

### G1

- Garbage-First
- 适用于整个堆
- 将堆分为Region，每次回收价值最大的Region
- 处理删除关系的变动，忽略新增关系

## 内存分配与回收策略

- Minor GC：发生在新生代的垃圾收集动作，非常频繁，回收速度快
- Major GC（Full GC）：发生在老年代的GC，速度一般比Minor GC慢10倍以上

### 对象优先砸Eden分配

- 当Eden区域没有足够的空间进行分配时，虚拟机会发起一次Minor GC

### 大对象直接进入老年代

- 需要大量连续内存空间的Java对象会直接进入老年代
- 程序要避免出现短命的大对象

### 长期存活的对象将进入老年代

- 每在Survivor区域中熬过一次，年龄就会+1，年龄到达一定限度，就会进入老年代

### 动态对象年龄判定

- 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuingThreashold中要求的年龄

### 空间分配担保

1. 在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
2. 如果不，Minor GC是不安全的
3. 接着查看HandlePromotionFailure是否允许冒险
4. 如果允许，继续检查老年代足以大可用的连续空间是否大于历次晋升到老年代对象的平均大小
5. 如果大于，则进行Minor GC
6. 3、4任何一步为否，或者担保失败都会进行一次Full GC

JDK6之后，HandlePromotionFailure不起作用，只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC

# 类文件结构

## Class类文件的结构

### 概述

- 每一个Class文件都对应着唯一一个类或接口的定义信息
- Class文件是一组以8位字节为基础单位的二进制流，大于8位的数据按照高位在前进行存储
- Class文件中只有无符号数和表两种数据类型
- 无符号数属于基本数据类型
- 表是由多个无符号数或者其他表作为数据项构成的符合数据类型
- 描述符：描述字段的数据类型，方法的参数列表（数量、顺序以及类型）和返回值；
- 描述符通过索引指向常量池中的内容
- 访问标志：类、方法、字段的访问修饰符

### 1-魔数与Class文件的版本

- 每个Class文件的头4个字节被称为魔数，唯一作用是确定这个文件是否能被虚拟机接受
- 后四个字节是Minor Version+Major Version

### 2-常量池

- 常量池的入口是u2类型的常量池容量计数值，1代表第一个，0代表不引用任何一个常量池项目
- 字面量：文本字符串、final的常量值等
- 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
- 动态连接：在虚拟机加载Class文件的时候，把方法、字段的符号引用转换为真正的内存入口地址

### 3-访问标志

- access_flags
- 两个字节
- 标识一些类或接口层次的访问信息
- 通过将标志值相加来得到结果

### 4-类索引、父类索引和接口索引集合

- 分别是u2、u2、u2集合
- 用于确认当前类的继承和实现关系
- 接口索引集合之前是一个接口计数器，表明接口的数量

### 5-字段表集合

- 即类或接口的成员变量，包括类级变量和实例级变量
- 对于数组类型，每一个维度通过一个前置的`[`来描述

![âJvmå­æ®µè¡¨âçå¾çæç´¢ç»æ](https://img2018.cnblogs.com/blog/595137/201812/595137-20181219204614678-2062186872.png)

### 6-方法表集合

- 方法中的代码，经过编译器编译成字节码后，存放在属性表集合的`Code`属性中
- Java语言无法仅仅通过返回值来对方法进行重载，但是在JVM中，只要描述符不是完全一致的两个方法就可以共存

![âJvmæ¹æ³è¡¨éåâçå¾çæç´¢ç»æ](https://lijiankun24.com/%E8%AE%A4%E8%AF%86-class-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/method_info.png)

# 虚拟机类加载机制

## 概述

- Java中，类型的加载、连接和初始化过程都是在程序运行期间完成的
- 加载过程：

![âç±»å è½½çæ¶æºâçå¾çæç´¢ç»æ](https://oscimg.oschina.net/oscnet/ad3d07c6c4dad9267668119f94ddf27442e.jpg)

## 类加载时机

- 加载、验证、准备、初始化和卸载是**按部就班的开始**的

### 类的立即初始化时机

1. 遇见new、getstatic、putstatis或invokestatic这四条字节码指令；例如new对象、读取或设置一个类的静态字段（除非在编译期已经把结果放入了常量池）、调用一个类的静态方法
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，需要先触发其初始化
3. 当初始化一个类的时候，发现其父类还没有进行过初始化
4. 虚拟机启动时候，包含main方法的那个类会先被初始化
5. 使用Java的动态语言支持时

### 类被动引用的时机

- 子类引用父类的静态字段，会触发父类的初始化，但子类不会被初始化（取决于JVM的实现）
- 使用数组来定义类，不会触发类的初始化
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

## 类加载的过程

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表此类的java.lang.Class对象

### 非数组类加载

- 既可以通过系统提供的引导类加载器完成，也可以通过用户自定义的列加载器完成

### 数组类加载

- 数组类通过JVM直接创建
- 数组类的元素类型通过类加载器创建

## 验证

- 确保Class文件的字节流中包含的信息符合
- 文件格式验证、元数据验证、字节码信息验证

## 准备

- 准备阶段正式为类变量分配内存并设置**类变量**初始值的阶段，这些变量所使用的内存都将在方法区中进行分配
- 一般情况下，初始值应该是各种数据类型的默认值，如果有赋值操作，应该在构造器中执行
- 对于类字段的字段属性表中存在ConstantValue属性，那么在准备阶段value就会被初始化为ConstantValue属性所指定的值

## 解析

- 