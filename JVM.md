# 第二章——Java内存区域与内存溢出异常

## 运行时数据区域

### 线程共享

#### Java堆

- 存放对象实例，数组
- 垃圾回收管理的主要区域
- 可以处于逻辑上连续，物理上不连续的内存空间

#### 方法区

- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

#### 运行时常量池

- 方法区的一部分
- 存放编译器生成的各种字面量和符号引用
- 动态性

### 非线程共享

#### 程序计数器

- 当前线程所执行的字节码的行号指示器
- 字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令
- Native方法计数器会为空

#### Java虚拟机栈

- 栈帧：用于存储局部变量表、操作数栈、动态链接等信息
- 方法调用时会创建一个栈帧，有相应的出栈入栈操作

#### 本地方法栈

- 类似于虚拟机栈，只不过执行的是本地方法

## 对象

### 对象的创建

1. 检查，类加载
2. 分配内存
3. 内存空间初始化为0

##### 指针碰撞

- 适用于Java堆内存是绝对工整的
- 分配内存时，仅需要把指针向空闲空间方向移动

##### 空闲列表

- 适用于Java堆内存是不工整的
- 通过维护一个列表来记录哪些内存块是可用的

### 对象的内存布局

#### 对象头

- Mark Word：第一部分用于存储对象自身的运行时数据
- 另一部分是类型指针，来确定对象那个是哪个类的实例

### 实例数据

- 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容
- 相同宽度的字段总是被分配在一起，在此前提下，父类定义的变量出现在子类之前

### 对象填充

- HotSpot VM要求对象起始地址必须是8字节的整数倍

### 对象的访问定位

#### 句柄访问

- Java堆中会划分出一块内存来作为句柄池
- reference存储对象的句柄地址
- 句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 好处：reference中鵆的稳定句柄地址，对象被移动时，不需要改变

#### 直接指针访问

- reference中存储的直接就是对象地址
- 速度快，节省了一次指针定位的时间开销
- Sun HotSpot采用这种方式

# 第三章——垃圾收集器与内存分配策略

## 对象是否存活

### 引用计数算法

#### 原理

- 每有一个地方引用对象时，引用计数器加1；每有一个引用失效时，引用计数器减1；当计数器为0时，对象被回收

#### 缺点

- 无法解决循环引用问题
- `ObjectA.attr = ObjectB, ObjectB.attr = ObjectA`

### 可达性分析算法

### 引用

- 强引用：通常意义上的引用
- 软引用：在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围之中进行二次回收
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前
- 虚引用：不对对象生存周期产生影响，唯一目的能在对象被GC回收时收到一个系统通知

### 对象回收

1. 先判断此对象是否要执行finalize()方法；方法没有被覆盖，或者已经执行过一次，则没有必要执行
2. 有必要执行的对象放入F-Queue队列之中去执行（只会触发方法，不会等待结束，避免GC崩溃）
3. 再次判断是否要回收该对象（如果在finalize方法中，对象有了一个新引用，就避免了被回收的命运）

### 回收方法区

- 主要是回收废弃常量和无用的类
- 回收效率低

#### 废弃常量

- 没有引用指向常量池中的常量

#### 无用的类

- 该类的所有实例都已经被回收
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象那个没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

