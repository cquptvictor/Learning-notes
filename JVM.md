# 第二章——Java内存区域与内存溢出异常

## 运行时数据区域

### 线程共享

#### Java堆

- 存放对象实例，数组
- 垃圾回收管理的主要区域
- 可以处于逻辑上连续，物理上不连续的内存空间

#### 方法区

- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

#### 运行时常量池

- 方法区的一部分
- 存放编译器生成的各种字面量和符号引用
- 动态性

### 非线程共享

#### 程序计数器

- 当前线程所执行的字节码的行号指示器
- 字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令
- Native方法计数器会为空

#### Java虚拟机栈

- 栈帧：用于存储局部变量表、操作数栈、动态链接等信息
- 方法调用时会创建一个栈帧，有相应的出栈入栈操作

#### 本地方法栈

- 类似于虚拟机栈，只不过执行的是本地方法

## 对象

### 对象的创建

1. 检查，类加载
2. 分配内存
3. 内存空间初始化为0

##### 指针碰撞

- 适用于Java堆内存是绝对工整的
- 分配内存时，仅需要把指针向空闲空间方向移动

##### 空闲列表

- 适用于Java堆内存是不工整的
- 通过维护一个列表来记录哪些内存块是可用的

### 对象的内存布局

#### 对象头

- Mark Word：第一部分用于存储对象自身的运行时数据
- 另一部分是类型指针，来确定对象那个是哪个类的实例

### 实例数据

- 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容
- 相同宽度的字段总是被分配在一起，在此前提下，父类定义的变量出现在子类之前

### 对象填充

- HotSpot VM要求对象起始地址必须是8字节的整数倍

### 对象的访问定位

#### 句柄访问

- Java堆中会划分出一块内存来作为句柄池
- reference存储对象的句柄地址
- 句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 好处：reference中鵆的稳定句柄地址，对象被移动时，不需要改变

#### 直接指针访问

- reference中存储的直接就是对象地址
- 速度快，节省了一次指针定位的时间开销
- Sun HotSpot采用这种方式

