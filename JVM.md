# 第二章——Java内存区域与内存溢出异常

## 运行时数据区域

### 线程共享

#### Java堆

- 存放对象实例，数组
- 垃圾回收管理的主要区域
- 可以处于逻辑上连续，物理上不连续的内存空间

#### 方法区

- 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

#### 运行时常量池

- 方法区的一部分
- 存放编译器生成的各种字面量和符号引用
- 动态性

### 非线程共享

#### 程序计数器

- 当前线程所执行的字节码的行号指示器
- 字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令
- Native方法计数器会为空

#### Java虚拟机栈

- 栈帧：用于存储局部变量表、操作数栈、动态链接等信息
- 方法调用时会创建一个栈帧，有相应的出栈入栈操作

#### 本地方法栈

- 类似于虚拟机栈，只不过执行的是本地方法

## 对象

### 对象的创建

1. 检查，类加载
2. 分配内存
3. 内存空间初始化为0

##### 指针碰撞

- 适用于Java堆内存是绝对工整的
- 分配内存时，仅需要把指针向空闲空间方向移动

##### 空闲列表

- 适用于Java堆内存是不工整的
- 通过维护一个列表来记录哪些内存块是可用的

### 对象的内存布局

#### 对象头

- Mark Word：第一部分用于存储对象自身的运行时数据
- 另一部分是类型指针，来确定对象那个是哪个类的实例

### 实例数据

- 对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容
- 相同宽度的字段总是被分配在一起，在此前提下，父类定义的变量出现在子类之前

### 对象填充

- HotSpot VM要求对象起始地址必须是8字节的整数倍

### 对象的访问定位

#### 句柄访问

- Java堆中会划分出一块内存来作为句柄池
- reference存储对象的句柄地址
- 句柄中包含了对象实例数据与类型数据各自的具体地址信息
- 好处：reference中鵆的稳定句柄地址，对象被移动时，不需要改变

#### 直接指针访问

- reference中存储的直接就是对象地址
- 速度快，节省了一次指针定位的时间开销
- Sun HotSpot采用这种方式

# 第三章——垃圾收集器与内存分配策略

## 对象是否存活

### 引用计数算法

#### 原理

- 每有一个地方引用对象时，引用计数器加1；每有一个引用失效时，引用计数器减1；当计数器为0时，对象被回收

#### 缺点

- 无法解决循环引用问题
- `ObjectA.attr = ObjectB, ObjectB.attr = ObjectA`

### 可达性分析算法

#### 原理

- 通过一系列的GC Root对象作为起始点，从这些结点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Root没有任何引用链，则该对象需要被回收

#### GC Root对象

- 虚拟机栈中引用的对象（即栈中本地变量表）
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中Native方法引用的对象

### 引用

- 强引用：通常意义上的引用
- 软引用：在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围之中进行二次回收
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前
- 虚引用：不对对象生存周期产生影响，唯一目的能在对象被GC回收时收到一个系统通知

### 对象回收

1. 先判断此对象是否要执行finalize()方法；方法没有被覆盖，或者已经执行过一次，则没有必要执行
2. 有必要执行的对象放入F-Queue队列之中去执行（只会触发方法，不会等待结束，避免GC崩溃）
3. 再次判断是否要回收该对象（如果在finalize方法中，对象有了一个新引用，就避免了被回收的命运）

### 回收方法区

- 主要是回收废弃常量和无用的类
- 回收效率低

#### 废弃常量

- 没有引用指向常量池中的常量

#### 无用的类

- 该类的所有实例都已经被回收
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象那个没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾收集算法

### 标记-清除算法

#### 原理

- 首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象

#### 特点

- 效率不高
- 空间零碎，分配大对象时不方便

### 复制算法

#### 原理

- 内存分为两块，将一块内存用完之后，就把存活的对象复制到另一块上，然后清除第一块

#### 特点

- 内存需要缩小一半

#### 实际应用

- 新生代按照Edent:Survivor:Survivor = 8:1:1划分
- 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

### 标记-整理算法

- 标记过程和标记-清除算法一样，但是并不直接对可回收对象清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集

- 将堆内存分为老年代和新生代，根据各个代不同的特点选择适当的收集算法

## HotSpot算法的实现

### 枚举根节点

- 一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上；保证对象的引用关系不会不断变化；因此需要`Stop The World`
- 为了方便的的值哪些地方存放着对象的引用，采用了OopMap的数据结构
- 在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用

### 安全点

- 在“特定位置记录了这些信息”，这些位置被称为安全点
- STW只有在到达安全点才能暂停
- 以“是否具有让程序尝试加难治性的特征”为标准选定

#### 抢先式中断

- 先把所有的线程中断，有的线程若不在安全点上，则恢复线程，运行到安全点再中断、
- 几乎不用

### 主动式中断

- 设置一个标志，线程执行时主动去轮询这个标志，发现标志为true时就自己中断

### 安全区域

- 指在一段代码片段中，引用关系不会发生变化
- 例如，线程处于Sleep或Blocked状态时

## 垃圾收集器

### CMS

- Concurrent Mark Sweep
- 一种以获取最短回收挺短时间为目标的收集器
- 适用于老年代
- 标记-清除算法

### 运作过程

1. 初始标记：标记GC Roots能直接关联到的对象，需要STW
2. 并发标记：进行GC Roots Tracing
3. 重新标记：修正标记并发期间的变动（处理新增关系不被GC，忽略删除关系），需要STW
4. 并发清除

### 缺点

- 对CPU资源敏感，占用CPU资源导致程序变慢
- 无法处理浮动垃圾
- 标记-清除算法产生空间碎片

### G1

- Garbage-First
- 适用于整个堆
- 将堆分为Region，每次回收价值最大的Region
- 处理删除关系的变动，忽略新增关系

## 内存分配与回收策略

- Minor GC：发生在新生代的垃圾收集动作，非常频繁，回收速度快
- Major GC（Full GC）：发生在老年代的GC，速度一般比Minor GC慢10倍以上

### 对象优先砸Eden分配

- 当Eden区域没有足够的空间进行分配时，虚拟机会发起一次Minor GC

### 大对象直接进入老年代

- 需要大量连续内存空间的Java对象会直接进入老年代
- 程序要避免出现短命的大对象

### 长期存活的对象将进入老年代

- 每在Survivor区域中熬过一次，年龄就会+1，年龄到达一定限度，就会进入老年代

### 动态对象年龄判定

- 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuingThreashold中要求的年龄

### 空间分配担保

1. 在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
2. 如果不，Minor GC是不安全的
3. 接着查看HandlePromotionFailure是否允许冒险
4. 如果允许，继续检查老年代足以大可用的连续空间是否大于历次晋升到老年代对象的平均大小
5. 如果大于，则进行Minor GC
6. 3、4任何一步为否，或者担保失败都会进行一次Full GC

JDK6之后，HandlePromotionFailure不起作用，只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC