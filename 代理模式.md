# 设计模式

## 代理模式

- 代理模式是指客户端并不直接调用实际的对象，而是通过调用代理，来间接的调用实际的对象。

### 静态代理

#### 三种角色

- 代理对象
- 被代理对象
- 代理和被代理对象的共同接口

#### 特点

- 在proxy类中的代理方法中调用被代理类的被代理方法（所以要实现相同的接口）
- 可以在调用方法之前执行其他操作
- 被代理的类型是实现预定好的
- 每一个代理类都必须实现一遍委托类的接口
- 代理类每一个接口对象对应一个委托对象

```
公共接口
public interface Subject {
    void visit();
}
```

```
被代理类
public class RealSubject implements Subject{
    private String name = "byhieg";
    @Override
    public void visit() {
        System.out.println(name);
    }
}
```

```
代理类
public class ProxySubject implements Subject{

    private Subject subject;//绑定被代理角色

    public ProxySubject(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void visit() {
        subject.visit();
    }
}
```



### 动态代理

- 动态代理有别于静态代理，是根据代理的对象，动态创建代理类；
- 可以避免静态代理中，代理类接口过多的情况

#### 步骤

1. 编写一个委托类的接口，即静态代理的（Subject接口）
2. 实现一个真正的委托类，即静态代理的（RealSubject类）
3. 创建一个动态代理类，实现`InvocationHandler`接口，并重写该`invoke`方法
4. 在测试类中，生成动态代理的对象。

###  `Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h)`

- `ClassLoader loader`：指定当前目标对象使用类加载器，获取加载器的方法是固定的。
-  `Class<?>[] interfaces`：目标对象实现的接口类型，使用泛型方式确认类型。
-  `InvocationHandler h`：事件处理。执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。

```

public class DynamicProxy implements InvocationHandler  {
    private Object object;//记录被代理的对象
    public DynamicProxy(Object object) {
        this.object = object;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(object, args);
        System.out.println("这是动态代理");
        return result;
    }
}
```

```
 public static void main(String[] args) {
        Subject realSubject = new RealSubject();
        DynamicProxy proxy = new DynamicProxy(realSubject);//被代理对象，传给Proxy
        ClassLoader classLoader = realSubject.getClass().getClassLoader();
        Subject subject = (Subject) Proxy.newProxyInstance(classLoader, new  Class[]{Subject.class}, proxy);
        subject.visit();
        }
```



- 当使用者调用了代理对象所代理的接口中的方法的时候，这个调用的信息会被传递给`InvocationHandler`的`invoke()`方法。在 `invoke()`方法的参数中可以获取到代理对象、方法对应的`Method`对象和调用的实际参数。`invoke()`方法的返回值被返回给使用者。