# 第二章——X86处理器架构

## 基本微机设计

- CPU中包含了寄存器，一个高频时钟、一个控制单元、一个算术逻辑单元
- 时钟：对CPU内部操作与系统其他组件进行同步
- 控制单元：协调参与机器指令执行的步骤序列
- 算术逻辑单元：指令算术运算
- 内存存储单元：用于在程序运行时保存指令与数据

## 指令的执行周期

- 取指、译码、执行

## 操作模式

- 三个主要操作模式：保护模式、实地址模式、系统管理模式
- 虚拟8086模式，是保护模式的特殊情况

### 保护模式

- 保护模式是处理器的原生状态，在这种模式下，所有的指令和特性都是可用的。
- 分配给程序的独立内存区被称为段，而处理器会阻止程序使用自身段范围之外的内存

### 虚拟8086模式

- 现代操作系统可以同时执行多个独立的虚拟8086会话

### 实地址模式

- 当程序需要直接访问系统内存和硬件设备时，这种模式就很有用了

### 系统管理模式

- 向操作系统提供了实现诸如电源管理和系统安全等功能的机制
- 这些功能通常是由计算机制造商实现，他们为一个特定的系统设定而定制处理器

## 基本执行环境

### 地址空间

- 在32位保护模式下，一个任务或程序最大可以寻址4GB的线性地址空间
- 扩展物理寻址的技术使得可以被寻址的物理内存空间增加到64GB

### 基本程序执行寄存器

- 寄存器是直接位于CPU内高速存储位置，其设计访问速度远高于传统存储器
- 8个通用寄存器，6个段寄存器、一个处理器状态标志寄存器、一个指令指针寄存器

### 通用寄存器

- 主要用于算术运算和数据传输



# 第三章——汇编语言基础

## 基本语言元素

### 第一个汇编程序

```
.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO,dwExitCode:DWORD
.data

.code
main PROC

	mov eax,5

     add eax,6

	INVOKE ExitProcess,0

main ENDP
```

- 第一行是.386伪指令，表明这是一个32位程序，能访问32位寄存器和地址
- 第二行选择了程序的内存模式（flat），确定了子程序的调用规范（stdcall）
- 第三行为运行时堆栈保留了4096字节的空间
- 第四行声明了ExitProcess函数的原型，函数名+PROTO关键字+逗号+输入参数列表，返回值0表示成功
- .data是数据段，定义数据
- .code是代码段
- 第七行表示主程序的入口
- 倒数第二行调用Windows服务停止程序，将控制权交还给系统
- 最后一行是主程序结束的标志

### 整数常量

以字母开头的16进制数必须加一个前置0，防止汇编器将其解释为标识符

### 整数型常量表达式

一种算术表达式，包含了整数常量和算术运算符，每个表达式的结果必须是一个整数

### 字符和字符串

- 每个字符占一个字节
- 不区分单双引号
- 包含空格字符
- 字符串最后以一个空字节（,0）结束

### 标识符

用于标识变量、常数、子程序和代码标签

- 不区分大小写
- 可以包含1——247个字符
- 第一个字符必须是字母、下划线等
- 不能与保留字相同

### 伪指令(IMPORTANT)

- 伪指令是嵌入源代码中的命令，由汇编器识别和执行。
- 伪指令不在运行时执行
- 不同的汇编器有不同的伪指令

### 指令(IMPORTANT)

四个组成

- 标号（可选）
- 指令助记符（必须）
- 操作数（通常必须）
- 注释（可选）

#### 标号

- 是一种标识符，是指令和数据的位置标记
- 程序代码区的标号必须以冒号结束

- 数据标号：`count DWORD 100`

- 代码标号 : `target: ...` 

#### 操作数

- 汇编语言指令操作数的个数范围是0-3个
- 有多个操作数时，通常第一个被称作目的操作数，第二个被称作源操作数

#### 注释

- 单行注释分号开头
- 块注释,符号任意但是不能出现在注释中

```
COMMENT !

!
```



## 汇编、链接和运行程序(IMPORTANT)

1. 源文件
2. 汇编器读取源文件，并生成目标文件或者是列表文件
3. 连接器读取并检查目标文件，以便发现该程序是否包含了对链接库中任何过程的调用，从链接库汇总赋值任何被请求的过程，将他们与目标文件相组合，生成可执行文件
4. 执行文件

## 数据定义（IMPORTANT）

| BYTE   | 定义字节       |
| ------ | -------------- |
| SBYTE  | 定义有符号字节 |
| WORD   | 定义字         |
| SWORD  | 定义有符号字   |
| DWORD  | 定义双字       |
| SDWORD | 定义有符号双字 |



### 多初始值

​	标号代表第一个初始值的偏移量

### DUP操作符

- 为多个数据项分配存储空间

- `BYTE 4 DUP("stack")` 	4*5一共占有20个字节
- DUP(?)代表未赋初值

### 小端顺序

- 最低有效字节放在分配给该数据的第一个内存地址中
- 即低字节放低位数据

## 符号常量

通过为整数表达式或文本指定标识符来创建符号常量

### 等号伪指令

- name =  expression：汇编器预处理阶段会把所有出现的name替换为expression

### 重定义

可以重复定义一个name

### 当前地址计数器

- $返回当前程序语句的偏移量

- 用于计算字符串或数组的大小

  ```
  string DWORD "abcd"
  stringSize = ($ - string)/4
  ```

### EQU伪指令

- name EQU expression：一个有效的整数表达式
- name EQU symbol：一个已经存在的符号名称（已经用=或EQU定义过了）
- name EQU <text\>：任何文本
- EQU的符号不能被重定义

# 第四章——数据传送、寻址和算术运算

## 数据传送指令

### MOV指令

- 两个操作数必须是同样的大小
- 两个操作数不能同时为内存操作数
- 指令指针寄存器（IP、EIP、RIP）不能作为目标操作数
- 标准格式：
  - `mov reg,reg`
  - `mov mem,reg`
  - `mov reg,mem`
  - `mov mem,imm`
  - `mov reg,imm`

### 整数的全零/符号扩展

- mov指令不能直接把一个小操作数赋给一个大的操作数
- 可以先把ECX置零，然后将值传入，这样对于负数会有问题
- 可以把ECX高位用源操作数的最高位来填充（符号扩展），然后将值传入，这样负数就不会有问题

```
零扩展
.data
count WORD 1
.code 
mov ecx,0
mov cx,count

```

```
符号扩展
.data
count WORD -16
.code 
mov ecx,0FFFFFFFFh
mov cx,count

```

### MOVZX和MOVSX

- 上面的方法每次改变太过于麻烦，这两个指令就是用来解决此问题的
- `reg,mem` or `reg,reg` 

#### MOVZX

- 用于无符号整数
- 会对源操作数进行全零扩展
- 源操作数不能是常数（常数就不知道大小了）

#### MOVSX

- 用于有符号整数
- 符号扩展时，在目的操作数的全部扩展位上*重复长度较小的操作数的最高位*

#### MOVSX、MOVZX和MOV的异同

- MOV的操作数大小必须相同，后两者只要求source不大于destination
- MOV有5中操作范围，后两者只有两种操作范围

#### XCHG

- 交换两个操作数的内存
- 不能是两个内存操作数
- 不能是立即数

#### LAHF和SAHF

- LAHF将EFLAGS寄存器的低字节复制到AH（一共有五个标志位）
- SAHF将AH的内容复制到EFLAGS寄存器的低字节
- 可以用来保存标志寄存器的内容

#### 直接-偏移量操作数

- [变量名+偏移量*每个数的字节大小]
- 括号不是必须的

## 加法和减法

### INC和DEC指令

- 表示寄存器或内存操作数加1或减1
- INC和DEC指令根据目标操作数的值的变化导致标志位的变化，但不影响CF（进位标志位）

### ADD指令

- 将源操作数和目的操作数相加，相加之和存在目的操作数中

### SUB指令

- 目的操作数减去源操作数

- add和sub的适用的操作数与mov指令相同

### NEG指令

- `neg reg/mem`
- 将对应操作数的所有位取反加1
- 相当于取相反数
- 如果NEG指令的目的操作数不能正确的存储，则该结果是无效的（即操作数的值不会发生改变，但状态标志位会变）

### 状态标志位(IMPORTANT)

- CF：进位标志位，意味着无符号整数的溢出；较小的无符号整数中减去较大的无符号整数时，也会把CF置1
- OF：溢出标志位，意味着有符号整数的溢出
- ZF：零标志位，意味着操作产生的结果为0
- SF：符号标志位，意味着操作产生的结果为负数；不区分有符号数和无符号数，通过最高有效位来决定符号标志位的值
- PF：奇偶标志位，意味着操作数**最低有效字节**的1的个数是否为偶数
- AC：辅助进位标志，操作数的位3有进位或借位

## 与操作数相关的运算符和伪指令

### OFFSET运算符（IMPRORTANT）

- `offset val`返回该数据标号距数据段起始位置的距离（即地址）

### ALIGN伪指令

- `align num`
- 将一个变量对齐到字节边界、字边界、双字边界等
- CPU处理偶地址数据比奇地址快得多
- 2,4,8,16不是偏移16个字节，而是对齐到地址是2,4,8,16的倍数的位置

### PTR运算符（IMPRORTANT）

- `WORD PTR mem`
- 重写一个已经被声明过的操作数的大小数据类型

### TYPE运算符

- `type mem`
- 返回变量的单个元素的大小，以字节为单位

### LENGTHOF运算符（IMPRORTANT）

- `lengthof array`
- 返回数组中的元素的个数
- 只能返回跨行数组的第一行的元素个数

### SIZEOF运算符（IMPRORTANT）

- 返回值等于LENGTHOF与TYPE返回值的乘积

### LABEL伪指令

- 插入一个标号，并定义它的大小，但不分配内存空间
- 它与下一个变量共享同一个内存位置

```
val1 LABEL WORD
val2 DWORD 12345678h
```

- val1的值是5678h（小端格式）；也可以用来合并成大数

## 间接寻址（IMPRORTANT）

### 间接操作数

- 任何一个32位通用寄存器加上括号就能构成一个间接操作数。
- `[esi]`得到的是寄存器中的地址所指向的内容
- `mov [esi],bl`:将bl的值放入esi中的地址所指向的内容
- 间接寻址无法直接知道数据的大小，需要先用PTR声明数据大小 ，`INC BYTE PTR [esi]`

### 数组

- `[esi]`通过间接操作数来进行遍历数组,需要先把首地址赋给esi

### 变址操作数

- `[constant + reg]` 或`constant[reg]` 寄存器中只存放相对偏移地址的增量

### 指针

- 如果一个变量包含另一个变量的地址，则称该变量为指针

- 指针的大小受处理器当前模式的影响（32或64位）

  ```
  node DWORD val1
  	OR
  node DWORD OFFSET val1
  ```

### TYPEDEF运算符

- `node TYPEDEF PTR BYTE`创建一个字节指针

## JMP和LOOP指令

### JMP指令

- `JMP dest`无条件转移到目的地址

### LOOP指令

- 有条件跳转，按照ECX计数器循环，每次循环ECX值会自动减一
- 如果ECX等于0，不发生跳转
- 先减一，再与0比较

```
L1:
   ***
   loop L1
```

- 嵌套循环需要考虑如何保存ecx的值，以及什么时候恢复



## 第五章——过程

## 堆栈操作（IMPORTANT）

- 栈顶进行出栈和入栈操作
- 栈底的地址最大，从栈底到栈顶逐渐减小
- ESP始终指向添加、压入到栈顶的最后一个数值的地址

### 堆栈的应用

- 当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区
- 执行Call指令时，堆栈中保存当前过程的返回地址
- 调用过程时，参数传递通过压入堆栈来实现
- 堆栈也为过程局部变量提供了临时的存储区域
- 利用栈先进后出的特性，来翻转字符串

### Push和Pop指令

#### PUSH指令

- 首先减少ESP的值，然后将源操作数复制到堆栈中
- 三种格式：
  - `push reg/mem16`
  - `push reg/mem32`
  - `push imm32`

### POP指令

- 先把ESP指向的内容复制出来，再增加ESP的值
- pop到内存操作数，只能是16位或32位；超过长度的会被截断

### PUSHFD和POPFD

- PUSHFD把32位的EFLAGS寄存器内容压入堆栈
- POPFD把32位的EFLAGS寄存器内容弹出

### PUSHAD，PUSHA，POPAD，POPA

- PUSHAD按照EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI的顺序把32位寄存器压入堆栈
- POPAD将寄存器按照相反的顺序弹出堆栈
- PUSHA和POPA作用与上述两者相同，只不过是16位寄存器
- 注意过程使用寄存器来返回结果时，该指令会覆盖掉结果

## 过程

- 过程通过PROC和ENDP指令（注意和main的结束标记的区别）来定义，并且必须有名字
- RET指令来强制返回到程序被调用的位置

```
SumOf PORC
	***
	ret
SumOf ENDP
```

### CALL和RET指令

- CALL指令调用一个过程，将其返回地址压入堆栈，再把别调用过程的地址复制到指针寄存器
- RET指令从一个过程中返回，从ESP指向的堆栈数值被弹回到EIP（指令指针寄存器）中

### 向过程传递参数

- 在call指令之前把要传入的参数放入寄存器中
- 如果是数组或字符串，可以把数组的首地址传给ESI，通过间接寻址

### 保存和恢复寄存器

#### USES运算符

- #### 在过程开始时生成PUSH指令把寄存器保存到堆栈；

- #### 在过程结束时，生成POP指令，恢复寄存器的值

```
SumOf PORC USES esi ecx eax
	***
	ret
SumOf ENDP
```

# 第六章——条件处理

| 操作 | 说明                                                      |
| ---- | --------------------------------------------------------- |
| AND  | 元擦作数和目的操作数进行逻辑与操作                        |
| OR   | 源操作数和目的操作数进行逻辑或操作                        |
| XOR  | 源操作数和目的操作数进行逻辑异或操作（同为0，异为1）      |
| NOT  | 对目标操作数进行非操作                                    |
| TEST | 源操作数和目的操作数进行逻辑与操作，并适当地设置CPU标志位 |



## 布尔和比较指令

### AND指令（IMPORTANT）

- `AND dest,source`:两个操作数的对应位之间进行（按位）逻辑与操作，并将结果放入目的操作数中
- 位屏蔽：AND指令可以清除一个操作数中的1个位或多个位，同时又不影响其他位
- AND指令总是<u>清除溢出和进位标志位</u>
- 应用：将字符进行大小写转换

### OR指令（IMPORTANT）

- `or dest,source`:两个操作数的对应位之间进行（按位）逻辑或操作，并将结果放入目的操作数中
- 可以在不影响其他位的情况下，将操作数汇总的一个位或多个位置为1
- OR指令总是清除进位和溢出标志位

### XOR指令

- `XOR dest,source`:两个操作数的对应位之间进行（按位）逻辑异或操作，并将结果放入目的操作数中
- 相同为0，相异为1
- 异或运算可以是简单的对称加密工具
- OR指令总是清除进位和溢出标志位
- 应用：进行奇偶校验

### NOT指令

- 翻转操作数中所有位
- 不影响标志位

### TEST指令

- 在两个操作数之间进行AND操作，不改变目的操作数，但会根据运算结果设置符号标志位、零标志位、奇偶标志位
- TEST指令总是清除进位和溢出标志位

### CMP指令

- `CMP dest,source`：**隐含**从目的操作数中减去源操作数的操作，实际并不修改任何操作数
- 按照结果修改溢出、符号、零、进位、辅助进位和奇偶标志位
- 通过标志位来判断数据的大小情况

## 条件跳转

### Jcond指令

- `Jcond dest`:当状态条件为真时，条件跳转指令就分支到目标标号
- JC:进位跳转
- JNC：无进位跳转
- JZ：为零跳转
- JNZ：非零跳转
- 详见p157

### 条件跳转指令类型

- 基于特定标志位
- 基于两数是否相等
- 基于无符号操作数的比较
- 基于有符号操作数的比较
- 详见157

#####                                                                                       基于特定标志位的跳转

| 助记符 | 说明       | 标志位 |
| ------ | ---------- | ------ |
| JZ     | 为零跳转   | ZF=1   |
| JNZ    | 非零跳转   | ZF=0   |
| JC     | 进位跳转   | CF=1   |
| JNC    | 无进位跳转 | CF=0   |
| JO     | 溢出跳转   | OF=1   |
| JNO    | 无溢出跳转 | OF=0   |
| JS     | 有符号跳转 | SF=1   |
|        | 无符号跳转 | SF=0   |
| JP     | 偶校验跳转 | PF=1   |
| JNP    | 奇校验跳转 | PF=0   |

##### 														  基于无符号数比较的跳转

| 助记符 | 说明             |
| ------ | ---------------- |
| JA     | 大于跳转         |
| JNBE   | 不小于或等于跳转 |
| JAE    | 大于或等于跳转   |
| JNB    | 不小于跳转       |
| JB     | 小于跳转         |
| JNAE   | 不大于或等于跳转 |
| JBE    | 小于或等于跳转   |
|        | 不大于跳转       |

##### 							                           基于有符号数的比较跳转

| 助记符 | 说明             |
| ------ | ---------------- |
| JG     | 大于跳转         |
| JNLE   | 不小于或等于跳转 |
| JGE    | 大于或等于跳转   |
| JNL    | 不小于跳转       |
| JL     | 小于跳转         |
| JNGE   | 不大于或等于跳转 |
| JLE    | 小于或等于跳转   |
| JNG    | 不大于跳转       |



## 条件循环指令

### LOOPZ和LOOPE指令

- 在LOOP指令的基础上，零标志位为一，才跳转

### LOPNZ和LOOPNE

- 在LOOP指令的基础上，ecx中无符号数值大于0，且零标志位为0，才跳转

## 条件结构（important）

- 定义：能够在不同的逻辑分支中触发选择的一个或多个条件表达式

#### 块结构的if表达式

- 实现思路：首先对布尔表达式求值，接着状态位受到影响，最后根据状态位的值进行条件跳转

#### 复合表达式

- 结合跳转指令，进行合适的跳转

##### 逻辑AND运算符

- 短路求值：如果第一个表达式为假，则不需要计算第二个表达式

##### 逻辑OR运算符

- 注意第一个表达式为true，就不用计算第二个表达式

### While循环

- 在循环体的第一、二句进行条件测试
- 使用JMP回到循环起点标号处

# 第七章——整数运算

## 移位和循环移位指令

### 逻辑移位和算术移位（IMPORTANT）

- 逻辑移位：空出来的位用来填充，被移走的位进入进位标志位

- 算术移位：空出来的位用原数据的符号位填充

### SHL指令（IMPORTANT）

- `SHL dest,count`:目的操作数逻辑左移，最低位用零填充，最高移位进入进位标志位；
- count可以使用立即数或者CL寄存器
- 多次移动，进位标志位保存的是最后移出的最高位
- 位元乘法：在数值范围内，左移n位，相当于将该数乘以 2^n ，对有符号数和无符号数都适用

### SHR指令（IMPORTANT）

- `SHR dest,count`:目的操作数右移移位，最高位用0填充，最低位被赋值到进位标志位
- 位元除法：右移n位，相当于将该数除以 2^n ，仅对无符号数适用

### SAL和SAR指令（IMPORTANT）

- 和SHL、SHR完全相同
- SAR填充的数据是以符号位为标准，所以可以用于有符号数的位元除法

### SHLD和SHRD指令（IMPORTANT）

- `SHLD dest,source，count`：将目的操作数左移指定位数，移动形成的空位由源操作数的高位填充，移出的位进入CF进位标志位
- `SHRD dest,source，count`：将目的操作数右移指定位数，形成的空位由源操作数的低位填充，移出的位进入CF进位标志位
- dest可以是16位或32位的寄存器或存储单元
- source可以是CL寄存器或8位立即数

### 三种移位指令的异同（IMPORTANT）

- 前两者必须要指定目的操作数的大小，如果是间接寻址就需要使用PTR
- 第三者不需要目的操作数的具体大小，可以使用间接寻址之类的，但是需要是16位或32位

### ROL和ROR指令

- `ROL reg,count`:把所有位都向左移，最高位复制到进位标志位和最低标志位
- `ROR reg,count`:把所有位都向右移，最高位复制到进位标志位和最低标志位

### RCL和RCR指令

- `RCL reg,count`:把所有位都向左移，最高位复制到进位标志位，进位标志位赋值到最低位
- `RCR reg,count`:把所有位都向右移，进位标志位复制到最高有效位，最低有效位赋值到进位标志位

### 有符号数溢出

- 如果有符号数循环移动一位生成的结果超过了目的操作数的有符号数范围，则溢出标志位置为1（即符号位取反）
- 循环移动次数大于1，则溢出标志位无意义

## 乘法和除法指令

### MUL指令

| 被乘数 | 乘数      | 乘积    |
| ------ | --------- | ------- |
| AL     | reg/mem8  | AX      |
| AX     | reg/mem16 | DX:AX   |
| EAX    | reg/mem32 | EDX:EAX |

- `MUL 乘数`：自动根据乘数的大小决定被乘数使用EAX，还是AX，还是AL
- 仅适用于无符号操作数
- 乘数和被乘数的大小需要一致
- 乘积的大小是他们的一倍（指位数）
- 如果乘积的高半部分不为0，进位标志位和溢出标志位置1

### IMUL指令

#### 单操作数

- `IMUL reg/mem`:单操作数的和MUL指令相同，但是会把符号位扩展到高半部分（没有值的地方都设置为符号位）

#### 双操作数

- `IMUL reg,reg/mem`:第一个操作数和第二个操作数相乘，乘积放在第一个操作数中
- 超出的会被截断，然后设置溢出和进位标志位

#### 三操作数格式

- 第一个操作数保存乘积，第二个操作数和第三个操作数相乘

### DIV指令

| 被除数  | 除数      | 商   | 余数 |
| ------- | --------- | ---- | ---- |
| AX      | reg/mem8  | AL   | AH   |
| DX:AX   | reg/mem16 | AX   | DX   |
| EDX:EAX | reg/mem32 | EAX  | EDX  |

- `DIV 除数`：自动根据除数的大小决定被除数使用EAX，还是AX，还是AL
- **存放余数的寄存器一定要先清零**

## 扩展加减法（IMPORTANT）

### ADC指令 

- `ADC dest,source`:将源操作数和进位标志的值都与目的操作数相加，且操作数的大小必须相同
- 高位存储在EDX(DX,DL)寄存器中，低位存储在EAX(AX.AL)寄存器中

### SSB指令

- `SSB dest,source`:从目的操作数中减去源操作数和进位标志的值
- 先进行低位减法，然后通过SSB指令进行高位和进位标志位相减

# 第八章——高级过程（IMPORTANT）

## 堆栈帧

- 堆栈帧：是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器

### EBP和ESP

- EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。方便程序员取值
- ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。

### 寄存器传参的缺点

- 需要入栈出栈来保存和恢复寄存器的值，导致代码混乱，还可能消除性能优势

#### 堆栈参数

- 在调用子程序前，把参数压入堆栈即可

#### 值传递和引用传递

- 值传递：该值的副本被压入堆栈
- 引用传递：该值的地址被压入堆栈

### 访问堆栈参数

1. `push ebp`：保存原来的基址
2. `mov ebp, esp`：EBP成为新的基址
3. `pop ebp`：在返回之前恢复原来的基址

#### 显示的堆栈参数

- 若堆栈参数的引用表达式形如`[ebp+8]`，则称它们为显示的堆栈参数

#### 清除堆栈

- 在子程序返回之前必须把参数从堆栈中删除，否导致内存泄露，或者子程序返回地址错乱

# 第九章——字符串和数组（IMPORTANT）

### 重复前缀

- 加上重复前缀，指令就可以用ECX作为计数器重复执行

| REP          | ECX>0时重复                |
| ------------ | -------------------------- |
| REPZ、REPE   | 零标志位置1，且ECX>0时重复 |
| REPNZ、REPNE | 零标志位为0，且ECX>0时重复 |

- 每重复一次，ecx的值自动减一

### 方向标志位

| 指令 | 方向标志位的值 | 对ESI和EDI的影响 | 地址顺序 |
| ---- | -------------- | ---------------- | -------- |
| CLD  | 0              | 增加             | 低到高   |
| STD  | 1              | 减少             | 高到低   |

### MOVSB、MOVSW和MOVSD

- 指令将数据从ESI指向的内存位置复制到EDI指向的内存位置，根据方向标志位，自动增加或减少寄存器数值

| 指令  |          | ESI和EDI增加或减少的数值 |
| ----- | -------- | ------------------------ |
| MOVSB | 复制字节 | 1                        |
| MOVSW | 复制字   | 2                        |
| MOVSD | 复制双字 | 4                        |

### SCASB、SCASW和SCASD

- 指令分别将AL/AX/EAX中的值与EDI寻址的一个字节/字/双字进行比较
- 可以结合重复前缀来寻找是否有匹配的字符，找到后，EDI指向的应该是匹配字符的下一个